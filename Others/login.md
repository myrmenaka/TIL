# ログインと認証・認可の仕組み

## 認証と認可

|  |  定義 | 具体例 |  
|:--:|:--:|:--:|  
| 認証 AuthN<br>Authentication |  誰であるかを確認すること | ログイン認証など |  
|  認可 AuthZ<br>Authorization | 特定の条件で権限を与えること | 家の鍵や切符など |  

認可：認証した人に対して何を許可するのか  
認証と認可はセット  

### ■ 認証方法

| 要素 | 知識情報<br>What you Know | 生体情報<br>What you are | 所有情報<br>What you have |  
|:--:|:--:|:--:|:--:|  
| 定義 | その人だけが知っている情報 | その人の情報 | その人が持っているもの |  
| 具体例 | ・ID<br>・パスワード<br>など | ・顔<br>・指紋<br>など | ・携帯電話<br>ICカード<br>など |  

#### 二段階認証と二要素認証

二段階認証：認証の1つの要素を複数回行うこと  
二要素認証：複数の認証の要素を行うこと  

## ユーザー登録はどのように行われているのか

### ■ 前提として`クライアントサーバーモデル`
・クライアントからサーバーに対してリクエストを送る  
・サーバーからレスポンスが返ってくる  

### ■ ユーザーの認証情報は
IDやパスワードなどの情報をHTTPの`POSTメソッド`を使用してサーバーに送信する  
そのデータをデータベースに保存する  

### ■ HTTPプロトコル

#### リクエストメソッド
・GET：GETパラメータ（URLに反映される）    
・POST：POSTメソッドのbodyの中にデータが入る（URLには反映されない）  
・DELETE  
・PUT  

### ■ なぜGETメソッドではなく、POSTメソッドを使うのか

✔ GETメソッドはURLにユーザー名やパスワードを含めて送信するため、URLから機密情報が流出してしまうが、POSTメソッドはデータをリクエストボディに含めて送信するためそのリスクが低減できる  
✔GETリクエストは簡単に同じリクエストを再送できるため、認証情報が再送されてしまう  
✔GETメソッドはURLの長さの制限が原因で送信できるデータ量に限界がある  

※ 検索結果をお気に入り登録したい場合などには、GETメソッドでないとできない  

### ■ ユーザー登録のプロセス

送られてきたパスワードは`ハッシュ化`して保存  
ハッシュ化：パスワードを一方向性に変換するハッシュ関数で変換  
→ 復号できない（一方向性の暗号化）

※ 単なる暗号化とは異なる  
　→ 暗号化の前提は復号できる  

### ■ なぜ暗号化ではなく、ハッシュ化なのか

|  |  |  
|:--:|:--:|  
| 暗号化 | 暗号アルゴリズムと鍵を用いてデータを変換する、鍵を用いて復元することが可能 |  
| ハッシュ化 | ハッシュ関数を用いてデータを不規則な文字列に変換する、復元は困難 |  

#### ハッシュ化の仕組み
同一のデータを同一のハッシュ値に変換し、ハッシュ値から元のデータを復元することが困難な性質を持つハッシュ関数を用いる  

#### ハッシュ化が安全である理由
パスワードを平文のままデータベース等に保存するとデータが流出した際にパスワードも特定されてしまうが、ハッシュ値のみを保存することでそのリスクを低減できる  

### ■ では、2回目以降のリクエストは？
HTTPプロトコルは、前回の通信情報を一切保持しない  
→ 毎回、独立した通信 ＝ `ステートレス` な通信という   

#### `ステートフル` な通信にしたいとき、`Cookie`が必要  

## ログインの際に行われるやり取り（Cookie）

受け取った情報とデータベース上の情報を照合し、一致すれば認証を許可  
受信したパスワードをハッシュ化したハッシュ値とデータベース上のハッシュ値を比較する  

### ■ 流れ

1．初回ログイン時、サーバーが`Cookie`を発行してレスポンス、クライアント（Webブラウザ）が保存する  
2．クライアントは、毎回の通信で必ずサーバーに`Cookie`を送る  
3．サーバーは、`Cookie`を見ることでクライアントを特定している  

→ ステートフルな通信ができる  

## セッションとは

| クライアント | サーバー |  
|:--:|:--:|  
| Cookieを送る | セッションIDを渡す |  

※ Cookieは入れ物 → その中にセッションIDをサーバーが入れる  
　→ 2回目以降のログイン時、サーバーは送られてきたCookieの中のセッションIDを照合する  

・`ログイン時にサーバーがセッションIDを発行する`  
・サーバー上にはセッションIDとそれに紐づいたユーザーの情報を保存する  
・ブラウザのCookieというファイルにセッションIDを保存  
　厳密には → `サーバー`が作ったCookieというものをクライアント上のCookiesという場所に保存  
・アクセスのたびにリクエストのヘッダーにセッションIDを加えて自動的に送信される  
・`サーバー`はセッションIDを照合してログイン状態を維持する  

サーバーはCookieの中のセッションIDを取り出す  
サーバーの中には、そのセッションIDに対応した保存場所が発行時に作られる（クライアントごとに）  

→ その保存場所を、`セッション` という  

※ つまり、クライアントがCookieを持っていても、サーバー側のセッション（保存場所）が無かったり壊れていると再ログインできなくなる  

### ■ セッションの保存先
#### サーバー側はセッションをどこに保存しているのか  

サーバーのメモリ / サーバーのファイル / ※ RDB / ※ NoSQL  
※ DB

・ファイルの場合：サーバーがクラッシュしてもデータはファイルに残る  
・メモリ上（プログラム上）の場合：クラッシュしたとき、  
　メモリは`揮発性`のためデータ消滅する

→ メモリ上は危険、でもファイルに保存するならDBに保存しよう！ → RDB / NoSQL  
データベースに保存してあれば、データベースのデータが消滅しない限りログインできる  

でも、`一般的なフレームワークは基本的にこのセッションを、メモリ上に保存する`ことが多い  

### ■ 分散サービスにおけるセッション
複数のサーバーに同時にアクセスする際、セッションがメモリ、ファイルで管理されている場合機能しなくなる  

→ なので、`データベースにセッションを保存`し、それぞれのサーバーは同一のDBを参照する  
セッションはメモリ上で管理してはいけない、DBに保存する！  

`セッションの分離`  
※ 例えば（Redis：セッション管理サービス → 速くてパフォーマンスがいい）などがある  

### ■ もう一つのセッション保存場所（非推奨）
※ できるよー程度  

前提として、  
Cookie ＝ クライアントの保存場所  
セッション ＝ サーバーの保存場所  

↓

`Cookie`の中にセッション情報も含める  

## Cookieの属性について

| 属性 | 定義 |  
|:--:|:--:|  
| Path | Cookieを送信するPATH |  
| Domain | Cookieを送信するドメイン |  
| Secure | HTTPSのみCookieの送信を許可 |  
| HttpOnly | CookieにJavaScript経由でアクセスさせない（XSS対策） |  
| Expired | Cookieの有効期限（日付） |  
| Max-Age | Cookieの有効期限（秒数） |  
| Same-Site | 他サイト経由でリクエスト時にCookieを送信するかどうか |  

### ■ Secure属性

HTTP通信では、Cookieが丸見え  
HTTPS通信だと、`Cookie自体が暗号化`されて送られる  

### ■ HttpOnly属性

ここにチェックが付いていないと、XSS攻撃されてしまう可能性がある（なりすましなど）  

### ■ Cookieは一時的な鍵

Expired / Max-Age で有効期限を設定できる  

## まとめ

### ■ ログインはなぜできるのか

アカウント登録では、ユーザーが入力したIDやパスワードなどの情報をHTTPのPOSTメソッドを使用してサーバーに送信する。POSTメソッドは、データをリクエストボディに含めて送信するためGETメソッドよりリスクが低減できる。送られたパスワードはハッシュ化されたハッシュ値を保存する。データベースが不正アクセスされてもパスワードの安全性が保たれる。  
HTTPはステートレスなプロトコルであり、各リクエストが独立して処理される。リクエストのたびに毎回ログインによる認証が必要になってしまうため、ステートフルな仕組みが必要になる。そのためにCookieとセッションIDが利用される。  
初回ログイン時、クライアントからのリクエストにサーバーはCookieを発行しその中にユーザー情報と紐づけたセッションIDを含めてクライアントへレスポンスを返す。2回目以降のログインでは、サーバーはクライアントから送られてくるリクエストのヘッダにあるCookieの中のセッションIDを参照し、D保存されているセッション情報と照合し、クライアントを認証しログインできるようになる。パスワードについては、ログイン時に受信したパスワードをハッシュ化して生成されたハッシュ値と、データベースに保存されているハッシュ値とを照合する。

## その他のログイン認証方法

| 認証 | 内容 |  
|:--:|:--:|  
| Basic認証 | ・HTTPプロトコルでサポートされている<br>・IDとパスワードをBase64で変換して送信する<br>※ ハッシュ化、暗号化されていないため、安全性が低い |  
| Digest認証 | ・HTTPプロトコルでサポートされている<br>・IDとパスワードをハッシュ化して送信する<br>・SSL/TLS通信ができない状況で使う |  
| JWTによる認証 | ・ユーザー側で保存する JSON Web Token によって認証する<br>・サーバー側でセッションを保持する必要がない<br>・デジタル署名を用いて改ざんを検知する |  
