# Arrayオブジェクトの主なメソッド

## 1. 要素を探す・判定する系
### includes()
・配列に値が含まれているか判定  
・戻り値：true / false  

```js
const arr = [1, 2, 3];
arr.includes(2); // true
```
### indexOf() / lastIndexOf()
・要素の位置（インデックス）を返す  
・見つからなければ -1  

```js
["a", "b", "c"].indexOf("b"); // 1
```
### find()
・条件に一致する最初の要素そのものを返す  

```js
const users = [{id:1}, {id:2}];
users.find(u => u.id === 2); // {id:2}
```
### findIndex()
・条件に一致する最初のインデックスを返す  

```js
users.findIndex(u => u.id === 2); // 1
```
### some()
・条件を満たす要素が1つでもあれば true  

```js
[1, 3, 5].some(n => n % 2 === 0); // false
```
### every()
・全ての要素が条件を満たすか  

```js
[2, 4, 6].every(n => n % 2 === 0); // true
```
## 2. 配列を変換する系（map/filter/reduce）
### map()
・各要素を変換して新しい配列を返す  

```js
[1, 2, 3].map(n => n * 2); // [2, 4, 6]
```
### filter()
・条件に合う要素だけを抽出

```js
[1, 2, 3, 4].filter(n => n % 2 === 0); // [2, 4]
```
### reduce()
・配列を1つの値に畳み込む（合計・集計など）  

```js
[1, 2, 3].reduce((sum, n) => sum + n, 0); // 6
```
### flat()
・ネストされた配列を平坦化  

```js
[1, [2, 3]].flat(); // [1, 2, 3]
```
### flatMap()
・map + flat(1) のセット

```js
["a b", "c d"].flatMap(s => s.split(" "));
// ["a", "b", "c", "d"]
```
## 3. 要素の追加・削除（破壊的メソッド）
### push()
・末尾に追加  
・元の配列が変わる  

```js
const arr = [1, 2];
arr.push(3); // arr = [1, 2, 3]
```
### pop()
・末尾を削除して返す
### unshift()
・先頭に追加
### shift()
・先頭を削除
### splice()
・任意の位置で追加・削除  
※ 破壊的なので注意  

```js
const arr = [1, 2, 3];
arr.splice(1, 1); // [2] を削除 → arr = [1, 3]
```

## ※ 破壊的（mutating）と非破壊的（non‑mutating）

### 破壊的メソッド

元の配列が直接変更される  
```js
const arr = [1, 2, 3];
arr.push(4);

console.log(arr); // [1, 2, 3, 4] ← 変わってる
```
#### メリット
・シンプルで直感的  
・パフォーマンスが良い場合もある  
#### デメリット
・どこで配列が変わったか追いにくい  
・バグの温床になりやすい（特に大規模コード）  

### 非破壊的メソッド

元の配列はそのまま、新しい配列を返す
```js
const arr = [1, 2, 3];
const newArr = arr.map(n => n * 2);

console.log(arr);    // [1, 2, 3] ← 変わらない
console.log(newArr); // [2, 4, 6]
```
#### メリット
・元のデータが壊れないので安全  
・関数型プログラミングと相性が良い  
・React/Vueなどのフロントエンドで必須の考え方  
#### デメリット
・新しい配列を作るのでメモリを使う  
・破壊的より少しだけ処理が重いこともある（でもほぼ気にしなくてOK）  

### 使い分け
#### 1. 状態を安全に扱いたい → 非破壊的
・Reactのstate更新  
・Laravelのバリデーション結果を整形  
・APIレスポンスを加工  
#### 2. 一時的な処理でOK → 破壊的でも可
・小さなスクリプト  
・パフォーマンス重視の場面  
・配列を使い捨てる処理  

## 4. 非破壊で部分取得・結合
### slice()
・部分配列を取得（非破壊）

```js
[1, 2, 3].slice(1, 3); // [2, 3]
```
### concat()
・配列を結合（非破壊）  

```js
[1, 2].concat([3, 4]); // [1, 2, 3, 4]
```
## 5. 並び替え・文字列化
### sort()
・並び替え（破壊的）  

```js
[3, 1, 2].sort(); // [1, 2, 3]
```
### reverse()
・逆順にする（破壊的）
### join()
・配列を文字列に変換  

```js
["a", "b"].join("-"); // "a-b"
```
## 6. ES2023以降の新しめのメソッド
### toSorted()
・sort の非破壊版  

```js
const arr = [3, 1, 2];
arr.toSorted(); // [1, 2, 3]（元は変わらない）
```
### toReversed()
・reverse の非破壊版
### with()
・指定インデックスの値を変更（非破壊）  

```js
const arr = [1, 2, 3];
arr.with(1, 99); // [1, 99, 3]
```

## 使い分けのコツ

| やりたいこと | 使うメソッド |  
|:--:|:--:|  
| 条件に合う1件を取得 | find() |  
| 条件に合う複数を取得 | filter() |  
| 配列を別の形に変換 | map() |  
| 集計・合計 | reduce() |  
| 配列を壊したくない | slice, concat, toSorted |  
| 配列を壊してもOK | push, pop, splice |  


