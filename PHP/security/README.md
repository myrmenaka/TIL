# 2025.7.3 - セキュリティの基礎 CSRF対策の基礎

## 目的

フォームに対する `CSRF（クロスサイトリクエストフォージェリ）攻撃` の仕組みを理解し、`トークンによる防止策` を実装できるようになる  

## 目次

- [`CSRF` とは](#1)
- [`CSRF` の対策方法](#2)
- [`トークン` の生成・検証の手順](#3)

## MEMO

<a id="1"></a>

### `CSRF` とは

- `C`ross-`S`ite `R`equest `F`orgery（クロスサイトリクエストフォージェリ）の略
- Webサイトの脆弱性を利用した攻撃手法の一つ  
- 攻撃者がユーザーの認証情報を悪用して、意図しないリクエストをWebサイトに送信させ、不正な操作を実行させるもの 

例）  
銀行サイトにログイン中に、悪意あるwebページを開くと、知らないうちに振込処理が実行される…など  

#### ※ XSS との違い  

- XSS (クロスサイトスクリプティング)  
    - 攻撃対象 : ユーザーのブラウザ  
    - 攻撃方法 : 悪意のあるスクリプトをWebページに注入し、ユーザーのブラウザ上で実行させる  
    - 狙い : 情報の窃取、不正な操作、マルウェア感染など  
    - 例）  
    ・掲示板にスクリプトを書き込み、他のユーザーのCookieを盗む  
    ・Webサイトの見た目を改ざんする  
    ・フィッシングサイトへ誘導する  
    - 対策例 :  
    ・出力時にエスケープ処理を行う (特別な意味を持つ文字を文字列として出力する)  
    ・Content Security Policy (CSP) を導入する  

- CSRF (クロスサイトリクエストフォージェリ)  
    - 攻撃対象 : Webアプリケーションのセッション管理  
    - 攻撃方法 : ユーザーの認証情報を悪用し、正規のWebサイトに偽装したリクエストを送信する  
    - 狙い : ユーザーの意図しない操作を強制的に実行させる (例: パスワード変更、不正送金)  
    - 例）  
    ・ECサイトで、ユーザーが気づかないうちに商品を注文させる  
    ・SNSで、ユーザーが意図しない投稿をさせる  
    ・銀行サイトで、ユーザーが気づかないうちに送金処理を実行させる  
    - 対策例 :  
    ・CSRFトークンを導入する  
    ・SameSite Cookie属性を設定する  
    ・Refererヘッダーを検証する  

[参考: CSRF(クロスサイトリクエストフォージェリ)とは？仕組みや被害、対策を解説](https://www.lanscope.jp/blogs/cyber_attack_pfs_blog/20231020_15621/)  

---
<a id="2"></a>

### `CSRF` の対策方法

- 最もポピュラーなCSRF対策として `トークン` の利用  
- `ワンタイムトークン` の仕組み  
→ フォームを表示するときにランダムなトークンを生成し、フォームとセッションの両方に保存  
→ 送信時にそのトークンが一致していれば正規ユーザーと判断する  
- 根本的な対策としては、信頼できるフレームワークやライブラリを利用する  

#### ※トークンとは
- ワンタイムパスワード (OTP):  
一定時間ごとに変わる、一度しか使えないパスワードのこと  
- トークン:  
OTPを生成する物理的な機器や、ソフトウェアのこと  

→ `ワンタイムトークン` とは、一度しか使えない使い捨てのパスワード（ワンタイムパスワード）を生成する機器のこと

[参考: CSRF対策｜しくみと最新の防御方法を解説](https://www.aeyescan.jp/blog/cross-site_request_forgeries/)

---
<a id="3"></a>

### `トークン` の生成・検証の手順

- `bin2hex(random_bytes(32))` で安全なトークンを生成
- トークンをセッションに保存し、フォームに `<input type="hidden">` で埋め込む
- 受信時にPOST値のトークンとセッション内のトークンが一致するか確認

[参考: PHPマニュアル : bin2hex()関数](https://www.php.net/manual/ja/function.bin2hex.php)

>※ `bin2hex(random_bytes(32))`  
このコードは `random_bytes(32)` で32バイトのランダムなバイナリデータを生成したあと、`bin2hex()` で16進数の文字列に変換しています。  
>[参考: 初心者も押さえておくべきWebセキュリティ vol.2 『クロスサイトリクエストフォージェリ（CSRF）』からの保護対策](https://engineering.webstudio168.jp/2023/05/how-to-protect-csrf/)
---

## セキュリティ面での注意

- トークンは `random_bytes()` などで十分に予測不可能な値を生成すること
- フォームごとに新しいトークンを生成し、使い回さない
- 必ずセッションを使って保存・検証し、直接入力された値に頼らないこと
- トークンをURLパラメータとして渡さない（GET経由は危険）

---

### 練習問題 

CSRF対策トークン を使ったフォーム送信処理を作る  

- form.php  
    トークン付きフォーム画面  
- confirm.php  
    トークン検証処理と送信内容の確認

---
## 作業チェックリスト

- トークンの生成とセッション保存ができたか
- トークンをフォームに埋め込めたか
- POSTされたトークンとセッションのトークンを正しく照合できたか
- トークンが不正な場合は処理を中断できたか

---
## 疑問・課題

```php
<input type="hidden" name="token" value="<?php echo htmlspecialchars($token, ENT_QUOTES, 'UTF-8'); ?>">
```
- ユーザーから見えない `hidden` フィールドでトークンを一緒に送信
- `htmlspecialchars()` でトークン値をHTMLエスケープして、XSS対策もしている

```php
if (!isset($_POST['token']) || $_POST['token'] !== $_SESSION['token']) {
    echo "不正なアクセスです。";
    exit;
};
```
- `isset($_POST['token'])`  
フォームからトークンが送信されているかを確認、なければアウト  
- `$_POST['token'] !== $_SESSION['token']`  
フォームに埋め込んだトークンと、サーバ側に保存していたトークンを照合   

→ CSRF攻撃をブロック する重要なチェック処理  

- 生成されたトークンは見れない？  
    → ブラウザの開発者ツール（デベロッパーツール）で見れる  
    例：Google Chrome の場合  
    - フォームの画面で右クリック →「検証（Inspect）」を選ぶ
    - Elementsタブで `<input type="hidden" name="token" ... >` を探す  
    - `value="..."` の部分にトークンが入っているのが見える  

→ 64桁くらいの英数字が見つかれば、それがトークン

---

参考: []()
